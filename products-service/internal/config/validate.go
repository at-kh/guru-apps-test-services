// Code generated by go-validator; DO NOT EDIT.
// Package config contains models and autogenerated validation code
package config

// Validate validates struct accordingly to fields tags
func (c Config) Validate() []string {
	var errs []string
	if e := c.Delivery.Validate(); len(e) > 0 {
		errs = append(errs, e...)
	}
	if e := c.Storage.Validate(); len(e) > 0 {
		errs = append(errs, e...)
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (d Delivery) Validate() []string {
	var errs []string
	if e := d.HTTPServer.Validate(); len(e) > 0 {
		errs = append(errs, e...)
	}
	if e := d.Broker.Validate(); len(e) > 0 {
		errs = append(errs, e...)
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (h HTTPServer) Validate() []string {
	var errs []string
	if h.ListenAddress == "" {
		errs = append(errs, "listen_address::is_required")
	}
	if h.ReadTimeout == 0 {
		errs = append(errs, "read_timeout::is_required")
	}
	if h.WriteTimeout == 0 {
		errs = append(errs, "write_timeout::is_required")
	}
	if h.GracefulTimeout == 0 {
		errs = append(errs, "graceful_timeout::is_required")
	}
	if h.BodySizeLimitBytes == 0 {
		errs = append(errs, "body_size_limit_bytes::is_required")
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (b Broker) Validate() []string {
	var errs []string

	return errs
}

// Validate validates struct accordingly to fields tags
func (s Storage) Validate() []string {
	var errs []string
	if e := s.Postgres.Validate(); len(e) > 0 {
		errs = append(errs, e...)
	}

	return errs
}

// Validate validates struct accordingly to fields tags
func (p Postgres) Validate() []string {
	var errs []string
	if p.DSN == "" {
		errs = append(errs, "dsn::is_required")
	}
	if p.Driver == "" {
		errs = append(errs, "driver::is_required")
	}
	if p.Dialect == "" {
		errs = append(errs, "dialect::is_required")
	}
	if p.MigrationDirectory == "" {
		errs = append(errs, "migration_directory::is_required")
	}
	if p.MigrationDirection == "" {
		errs = append(errs, "migration_direction::is_required")
	}
	if p.RetryDelay == 0 {
		errs = append(errs, "retry_delay::is_required")
	}
	if p.ConnMaxIdleNum == 0 {
		errs = append(errs, "conn_max_idle_num::is_required")
	}
	if p.ConnMaxOpenNum == 0 {
		errs = append(errs, "conn_max_open_num::is_required")
	}
	if p.MaxRetries == 0 {
		errs = append(errs, "max_retries::is_required")
	}
	if p.MaxRetries != 0 && p.MaxRetries < 0 {
		errs = append(errs, "max_retries::min_value_is::0")
	}

	return errs
}
